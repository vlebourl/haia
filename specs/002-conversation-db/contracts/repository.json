{
  "contract_version": "1.0.0",
  "interface_name": "ConversationRepository",
  "description": "Repository for conversation and message persistence with context window management",
  "implementation_file": "src/haia/db/repository.py",
  "dependencies": [
    "sqlalchemy.ext.asyncio.AsyncSession",
    "haia.db.models.Conversation",
    "haia.db.models.Message"
  ],
  "methods": [
    {
      "name": "create_conversation",
      "description": "Create a new conversation and persist to database",
      "signature": "async def create_conversation(self) -> Conversation",
      "parameters": [],
      "returns": {
        "type": "Conversation",
        "description": "Newly created conversation with auto-generated ID and timestamps"
      },
      "raises": [
        {
          "exception": "sqlalchemy.exc.SQLAlchemyError",
          "condition": "Database write fails"
        }
      ],
      "side_effects": [
        "Inserts new row into conversations table",
        "Commits transaction via session"
      ],
      "example": "conversation = await repo.create_conversation()"
    },
    {
      "name": "get_conversation",
      "description": "Retrieve a conversation by ID with all messages eagerly loaded",
      "signature": "async def get_conversation(self, conversation_id: int) -> Conversation | None",
      "parameters": [
        {
          "name": "conversation_id",
          "type": "int",
          "description": "Unique identifier of the conversation",
          "constraints": "Must be positive integer"
        }
      ],
      "returns": {
        "type": "Conversation | None",
        "description": "Conversation object with messages relationship loaded, or None if not found"
      },
      "raises": [
        {
          "exception": "sqlalchemy.exc.SQLAlchemyError",
          "condition": "Database query fails"
        }
      ],
      "side_effects": [
        "Executes SELECT query with JOIN to load messages"
      ],
      "example": "conversation = await repo.get_conversation(123)"
    },
    {
      "name": "add_message",
      "description": "Add a new message to an existing conversation and update conversation timestamp",
      "signature": "async def add_message(self, conversation_id: int, role: str, content: str) -> Message",
      "parameters": [
        {
          "name": "conversation_id",
          "type": "int",
          "description": "ID of conversation to add message to",
          "constraints": "Must exist in database"
        },
        {
          "name": "role",
          "type": "str",
          "description": "Message role (system, user, or assistant)",
          "constraints": "Must be one of: 'system', 'user', 'assistant'"
        },
        {
          "name": "content",
          "type": "str",
          "description": "Message text content",
          "constraints": "Must be non-empty string, max 100,000 characters"
        }
      ],
      "returns": {
        "type": "Message",
        "description": "Newly created message with auto-generated ID and timestamp"
      },
      "raises": [
        {
          "exception": "ValueError",
          "condition": "conversation_id not found or invalid role"
        },
        {
          "exception": "sqlalchemy.exc.SQLAlchemyError",
          "condition": "Database write fails"
        }
      ],
      "side_effects": [
        "Inserts new row into messages table",
        "Updates conversation.updated_at timestamp",
        "Commits transaction via session"
      ],
      "example": "message = await repo.add_message(123, 'user', 'Hello, assistant!')"
    },
    {
      "name": "get_context_messages",
      "description": "Retrieve the N most recent messages for LLM context window",
      "signature": "async def get_context_messages(self, conversation_id: int, limit: int = 20) -> list[Message]",
      "parameters": [
        {
          "name": "conversation_id",
          "type": "int",
          "description": "ID of conversation to retrieve messages from",
          "constraints": "Must be positive integer"
        },
        {
          "name": "limit",
          "type": "int",
          "description": "Maximum number of messages to retrieve",
          "constraints": "Default: 20, Range: 1-100",
          "default": 20
        }
      ],
      "returns": {
        "type": "list[Message]",
        "description": "List of messages in chronological order (oldest first), limited to N most recent"
      },
      "raises": [
        {
          "exception": "sqlalchemy.exc.SQLAlchemyError",
          "condition": "Database query fails"
        }
      ],
      "side_effects": [
        "Executes SELECT query with ORDER BY and LIMIT"
      ],
      "performance": {
        "time_complexity": "O(log N + limit)",
        "notes": "Uses composite index on (conversation_id, created_at) for efficient sorting"
      },
      "example": "messages = await repo.get_context_messages(123, limit=20)"
    },
    {
      "name": "get_all_messages",
      "description": "Retrieve all messages in a conversation for display/debugging",
      "signature": "async def get_all_messages(self, conversation_id: int) -> list[Message]",
      "parameters": [
        {
          "name": "conversation_id",
          "type": "int",
          "description": "ID of conversation to retrieve messages from",
          "constraints": "Must be positive integer"
        }
      ],
      "returns": {
        "type": "list[Message]",
        "description": "List of all messages in chronological order (oldest first)"
      },
      "raises": [
        {
          "exception": "sqlalchemy.exc.SQLAlchemyError",
          "condition": "Database query fails"
        }
      ],
      "side_effects": [
        "Executes SELECT query with ORDER BY (no LIMIT)"
      ],
      "performance": {
        "time_complexity": "O(N)",
        "notes": "Loads all messages - use get_context_messages() for LLM processing"
      },
      "example": "all_messages = await repo.get_all_messages(123)"
    },
    {
      "name": "delete_conversation",
      "description": "Delete a conversation and all associated messages (CASCADE)",
      "signature": "async def delete_conversation(self, conversation_id: int) -> bool",
      "parameters": [
        {
          "name": "conversation_id",
          "type": "int",
          "description": "ID of conversation to delete",
          "constraints": "Must be positive integer"
        }
      ],
      "returns": {
        "type": "bool",
        "description": "True if conversation existed and was deleted, False if not found"
      },
      "raises": [
        {
          "exception": "sqlalchemy.exc.SQLAlchemyError",
          "condition": "Database delete fails"
        }
      ],
      "side_effects": [
        "Deletes row from conversations table",
        "Automatically deletes all messages via CASCADE constraint",
        "Commits transaction via session"
      ],
      "example": "deleted = await repo.delete_conversation(123)"
    },
    {
      "name": "list_conversations",
      "description": "List all conversations ordered by last activity (most recent first)",
      "signature": "async def list_conversations(self, limit: int = 50, offset: int = 0) -> list[Conversation]",
      "parameters": [
        {
          "name": "limit",
          "type": "int",
          "description": "Maximum number of conversations to retrieve",
          "constraints": "Default: 50, Range: 1-100",
          "default": 50
        },
        {
          "name": "offset",
          "type": "int",
          "description": "Number of conversations to skip (for pagination)",
          "constraints": "Default: 0, Minimum: 0",
          "default": 0
        }
      ],
      "returns": {
        "type": "list[Conversation]",
        "description": "List of conversations ordered by updated_at DESC (most recent first)"
      },
      "raises": [
        {
          "exception": "sqlalchemy.exc.SQLAlchemyError",
          "condition": "Database query fails"
        }
      ],
      "side_effects": [
        "Executes SELECT query with ORDER BY, LIMIT, and OFFSET"
      ],
      "performance": {
        "time_complexity": "O(log N + limit)",
        "notes": "Uses index on updated_at for efficient sorting"
      },
      "example": "conversations = await repo.list_conversations(limit=10)"
    },
    {
      "name": "get_message_count",
      "description": "Get total number of messages in a conversation",
      "signature": "async def get_message_count(self, conversation_id: int) -> int",
      "parameters": [
        {
          "name": "conversation_id",
          "type": "int",
          "description": "ID of conversation to count messages for",
          "constraints": "Must be positive integer"
        }
      ],
      "returns": {
        "type": "int",
        "description": "Total number of messages in conversation (0 if conversation doesn't exist)"
      },
      "raises": [
        {
          "exception": "sqlalchemy.exc.SQLAlchemyError",
          "condition": "Database query fails"
        }
      ],
      "side_effects": [
        "Executes COUNT query"
      ],
      "performance": {
        "time_complexity": "O(1)",
        "notes": "SQLite COUNT(*) is optimized when using indexes"
      },
      "example": "count = await repo.get_message_count(123)"
    }
  ],
  "usage_patterns": {
    "dependency_injection": {
      "description": "Repository is instantiated per-request via FastAPI dependency injection",
      "pattern": "repo = ConversationRepository(session)",
      "session_source": "Depends(get_db) in FastAPI endpoints"
    },
    "session_lifecycle": {
      "description": "Repository does not manage session lifecycle - caller is responsible",
      "commit_pattern": "Session auto-commits on success, rolls back on exception",
      "notes": "Do not call session.commit() or session.rollback() in repository methods"
    },
    "error_handling": {
      "description": "Repository propagates SQLAlchemy exceptions to caller",
      "pattern": "Caller should catch SQLAlchemyError and handle appropriately",
      "example": "try:\n    msg = await repo.add_message(...)\nexcept SQLAlchemyError as e:\n    logger.error(f'DB error: {e}')\n    raise HTTPException(status_code=500)"
    }
  },
  "test_requirements": {
    "unit_tests": [
      "Mock AsyncSession and verify SQL queries generated",
      "Test error handling for invalid inputs",
      "Test context window limit logic (exactly N messages returned)"
    ],
    "integration_tests": [
      "Test with real SQLite database (in-memory or temp file)",
      "Verify CASCADE delete behavior",
      "Test concurrent writes to same conversation"
    ]
  },
  "performance_guarantees": {
    "create_conversation": "< 5ms average",
    "add_message": "< 10ms average",
    "get_context_messages": "< 20ms for conversations up to 1000 messages",
    "get_all_messages": "< 50ms for conversations up to 1000 messages",
    "list_conversations": "< 30ms for up to 100 conversations"
  },
  "thread_safety": {
    "note": "Repository is NOT thread-safe",
    "reason": "AsyncSession is not thread-safe",
    "solution": "Use one repository instance per async task/request"
  }
}
